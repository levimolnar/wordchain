{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\Levi\\\\Desktop\\\\chaingamegh\\\\client\\\\src\\\\components\\\\WordInput.tsx\",\n  _s = $RefreshSig$();\nimport { useContext, useState } from \"react\";\nimport { GameContext } from \"../App\";\n\n// import { io } from 'socket.io-client';\n// const socket = io(\"http://localhost:3001\");\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nimport { Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nconst url = \"https://api.gbif.org/v1/species/search\";\nconst params = \"?highertaxon_key=1&qField=VERNACULAR&limit=250&q=\";\nexport const WordInput = ({\n  emitFunc\n}) => {\n  _s();\n  var _Array$from$at2;\n  const {\n    history,\n    yourTurn\n  } = useContext(GameContext);\n  const [submitDebounce, setSubmitDebounce] = useState(false);\n  const [wordError, setWordError] = useState(\"\");\n  const toUniqueNames = arr => Array.from(new Set(arr.map(i => i.vernacularName.toUpperCase())));\n  const validateAnimal = async search => {\n    try {\n      if (history.has(search)) {\n        throw Error(\"Animal name was already used.\");\n      }\n      const response = await fetch([url, params, search].join(\"\"));\n      const {\n        results\n      } = await response.json();\n      if (!results.length) {\n        throw Error(`Could not find animal named \"${search}\".`);\n      }\n      const fetchedNames = results.map(a => a.vernacularNames);\n      const fetchedNamesSorted = fetchedNames.sort((a, b) => a.length - b.length);\n      const matchingNames = fetchedNamesSorted.find(arr => {\n        return arr.some(({\n          vernacularName,\n          language\n        }) => vernacularName.toUpperCase() === search && language === \"eng\");\n      });\n      if (!matchingNames) {\n        throw Error(`Could not find animal named \"${search}\".`);\n      }\n      const matchingNamesEnglish = matchingNames.filter(({\n        language\n      }) => language === \"eng\");\n      const matchingNamesUnique = toUniqueNames(matchingNamesEnglish);\n      return matchingNamesUnique;\n    } catch (err) {\n      if (err instanceof Error) {\n        setWordError(err.toString().split(\":\")[1]);\n        setTimeout(() => setWordError(\"\"), 2000);\n      }\n      ;\n    }\n    ;\n  };\n  const submitSearch = e => {\n    e.preventDefault();\n    if (!submitDebounce) {\n      setSubmitDebounce(true);\n      setTimeout(async () => {\n        var _Array$from$at;\n        const previousEndLetter = (_Array$from$at = Array.from(history).at(-1)) === null || _Array$from$at === void 0 ? void 0 : _Array$from$at.at(-1);\n        const word = previousEndLetter ? previousEndLetter + e.target.animal.value : e.target.animal.value;\n        const animalValidated = await validateAnimal(word.toUpperCase());\n        // console.log(\"found:\", animalValidated);\n\n        if (animalValidated) {\n          const newHistory = new Set([...Array.from(history), word.toUpperCase()]);\n          emitFunc(Array.from(newHistory));\n          e.target.animal.value = \"\";\n        }\n        ;\n        setSubmitDebounce(false);\n      }, 30);\n    }\n    ;\n  };\n  return /*#__PURE__*/_jsxDEV(\"form\", {\n    className: \"wordForm\",\n    onSubmit: e => submitSearch(e),\n    autoComplete: \"off\",\n    children: [yourTurn ? /*#__PURE__*/_jsxDEV(_Fragment, {\n      children: [/*#__PURE__*/_jsxDEV(\"span\", {\n        className: \"firstLetter\",\n        children: (_Array$from$at2 = Array.from(history).at(-1)) === null || _Array$from$at2 === void 0 ? void 0 : _Array$from$at2.at(-1)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 83,\n        columnNumber: 13\n      }, this), /*#__PURE__*/_jsxDEV(\"input\", {\n        className: \"wordField\",\n        type: \"text\",\n        name: \"animal\",\n        placeholder: history.size ? \"\" : \"animal common name\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 86,\n        columnNumber: 13\n      }, this)]\n    }, void 0, true) : /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"wordDisplay\",\n      children: /*#__PURE__*/_jsxDEV(\"i\", {\n        children: \"WAIT YOUR TURN...\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 94,\n        columnNumber: 13\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 93,\n      columnNumber: 11\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"error\",\n      children: wordError\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 97,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 75,\n    columnNumber: 5\n  }, this);\n};\n_s(WordInput, \"lIuE2malSSioQqWFaRFDdaC4owY=\");\n_c = WordInput;\nvar _c;\n$RefreshReg$(_c, \"WordInput\");","map":{"version":3,"names":["useContext","useState","GameContext","jsxDEV","_jsxDEV","Fragment","_Fragment","url","params","WordInput","emitFunc","_s","_Array$from$at2","history","yourTurn","submitDebounce","setSubmitDebounce","wordError","setWordError","toUniqueNames","arr","Array","from","Set","map","i","vernacularName","toUpperCase","validateAnimal","search","has","Error","response","fetch","join","results","json","length","fetchedNames","a","vernacularNames","fetchedNamesSorted","sort","b","matchingNames","find","some","language","matchingNamesEnglish","filter","matchingNamesUnique","err","toString","split","setTimeout","submitSearch","e","preventDefault","_Array$from$at","previousEndLetter","at","word","target","animal","value","animalValidated","newHistory","className","onSubmit","autoComplete","children","fileName","_jsxFileName","lineNumber","columnNumber","type","name","placeholder","size","_c","$RefreshReg$"],"sources":["C:/Users/Levi/Desktop/chaingamegh/client/src/components/WordInput.tsx"],"sourcesContent":["import { useContext, useState } from \"react\";\r\nimport { GameContext } from \"../App\";\r\n\r\n// import { io } from 'socket.io-client';\r\n// const socket = io(\"http://localhost:3001\");\r\n\r\nconst url = \"https://api.gbif.org/v1/species/search\"\r\nconst params = \"?highertaxon_key=1&qField=VERNACULAR&limit=250&q=\"\r\n\r\nexport const WordInput = ({ emitFunc }: { emitFunc: (newHistory: string[]) => void }) => {\r\n\r\n  const { history, yourTurn } = useContext(GameContext);\r\n\r\n  const [submitDebounce, setSubmitDebounce] = useState<boolean>(false);\r\n  const [wordError, setWordError] = useState<string>(\"\");\r\n\r\n  const toUniqueNames = (arr: Array<{vernacularName: string, language: string}>) => Array.from(new Set(arr.map(i => i.vernacularName.toUpperCase())));\r\n\r\n  const validateAnimal = async (search: string) => {\r\n    try {\r\n\r\n      if (history.has(search)) { throw Error (\"Animal name was already used.\") }\r\n\r\n      const response = await fetch([url, params, search].join(\"\"));\r\n      const { results } = await response.json();\r\n\r\n      if (!results.length) { throw Error (`Could not find animal named \"${search}\".`) }\r\n\r\n      const fetchedNames = results.map((a: any) => a.vernacularNames);\r\n      const fetchedNamesSorted = fetchedNames.sort((a: any[], b: any[]) => a.length - b.length);\r\n      const matchingNames = fetchedNamesSorted.find((arr: Array<{vernacularName: string, language: string}>) => {\r\n        return arr.some(({ vernacularName, language }) => vernacularName.toUpperCase() === search && language === \"eng\")\r\n      });\r\n\r\n      if (!matchingNames) { throw Error (`Could not find animal named \"${search}\".`) }\r\n\r\n      const matchingNamesEnglish = matchingNames.filter(({language}: {language: string}) => language === \"eng\");\r\n      const matchingNamesUnique = toUniqueNames(matchingNamesEnglish);\r\n  \r\n      return matchingNamesUnique;\r\n\r\n    } catch(err: any) { \r\n      if (err instanceof Error) {\r\n        setWordError(err.toString().split(\":\")[1]);\r\n        setTimeout(() => setWordError(\"\"), 2000);\r\n      };\r\n    };\r\n  };\r\n\r\n  const submitSearch = (e: any) => {\r\n    e.preventDefault();\r\n\r\n    if (!submitDebounce) {\r\n      setSubmitDebounce(true);\r\n      setTimeout(async () => {\r\n\r\n        const previousEndLetter = Array.from(history).at(-1)?.at(-1);\r\n        const word = previousEndLetter ? previousEndLetter + e.target.animal.value : e.target.animal.value;\r\n\r\n        const animalValidated = await validateAnimal(word.toUpperCase());\r\n        // console.log(\"found:\", animalValidated);\r\n\r\n        if (animalValidated) {\r\n          const newHistory = new Set([...Array.from(history), word.toUpperCase()]);\r\n          emitFunc(Array.from(newHistory));\r\n          e.target.animal.value = \"\";\r\n        };\r\n\r\n        setSubmitDebounce(false);\r\n      }, 30); \r\n    };\r\n  };\r\n\r\n  return (\r\n    <form \r\n      className=\"wordForm\"\r\n      onSubmit={e => submitSearch(e)}\r\n      autoComplete=\"off\"\r\n    >\r\n      {\r\n        yourTurn\r\n        ? <>\r\n            <span className=\"firstLetter\">\r\n              {Array.from(history).at(-1)?.at(-1)}\r\n            </span>\r\n            <input \r\n              className=\"wordField\"\r\n              type=\"text\" \r\n              name=\"animal\"\r\n              placeholder={history.size ? \"\" : \"animal common name\"}\r\n            />\r\n          </>\r\n        : <div className=\"wordDisplay\">\r\n            <i>WAIT YOUR TURN...</i>\r\n          </div>\r\n      }\r\n      <div className=\"error\">\r\n        {wordError}\r\n      </div>\r\n    </form>\r\n  );\r\n};"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}